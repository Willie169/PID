# PID

[English](README.md)

此儲存庫實作了 PID（比例積分微分）控制器，旨在調節具有引導機器人的自動跟隨卡丁車的速度。此實作包括 PID 控制器邏輯、汽車模擬以及用於測試各種 PID 配置的框架。

## PID.hpp

### 概述

此頭檔實作了一個 PID 控制器，其中包括傳統的 PID 控制邏輯以及自適應增益調整、自適應積分項、錯誤歷史管理和附加微分項等增強功能。它還設計為與 Arduino 和非 Arduino 環境相容。

### Arduino 和非 Arduino 相容性

此接頭設計相容於 Arduino 和非 Arduino 環境。這使得開發人員可以在不同平台上使用相同的 PID 控制器實作。

條件編譯：
```cpp
#ifdef ARDUINO
#include <Arduino.h>
#include <math.h>
#define to_string(a) String(a)
#else
#include <cmath>
#include <string>
#define String string
using namespace std;
#endif
```

### 傳統PID控制器

傳統的PID控制器由以下方程式定義：

$$
u(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt} 
$$

其中：
- $u(t)$ 是控制輸出。
- $e(t)$ 是時間$t$ 時的誤差，定義為期望值與測量值之間的差異。
- $K_p$、$K_i$ 和 $K_d$ 分別是比例增益、積分增益和微分增益。

### 自適應增益調整

比例增益 $K_p$ 根據當前誤差 $e(t)$ 與其變化率（導數）之間的交互作用進行動態調整。此調整旨在提高控制器對不斷變化的條件的響應能力。適應可以在數學上表達如下：

$$
K_p' = K_p \times (1 \pm eDP_a)
$$

其中：
- $eDP = e(t) \times \frac{de(t)}{dt}$
- $eDP_m$ 是決定何時調整比例增益的閾值。
- $eDP_a$ 是根據誤差導數縮放 $K_p$ 變化的調整因子。

此調整背後的關鍵想法是，當系統遇到較大誤差且變化率顯著時（這可能表示即將出現超調或振盪），增加比例增益。反之，如果誤差在減少但仍然較大，則可以減少比例增益以防止過度校正，使系統更平穩地穩定。

### 自適應積分項

積分控制對於消除穩態誤差至關重要；然而，它可能會導致積分飽和等問題，即積分項在持續誤差期間過度累積。為了緩解這種情況，積分增益 $K_i$ 自適應計算如下：

$$
K_i = K_p \times rTiM \times ap
$$

其中：
- $ap = e^{-\frac{\text{amp}}{\text{maxAmp}}}$
- $rTiM$ 是與所需積分時間常數相關的常數。

變數 $amp$ 表示在會話期間觀察到的最大誤差幅度。透過使用指數衰減因子 $ap$，在高誤差期間積分項的貢獻會減小，從而有效降低飽和風險。當誤差在可接受的範圍內時，$ap$接近1，允許積分項有效地影響控制輸出。

### 錯誤歷史管理

受**齊格勒-尼科爾斯調整方法**的啟發，該實現保留了過去錯誤及其時間戳的歷史記錄，以準確計算導數和積分項。這種歷史管理至關重要，主要有兩個原因：

- **推導變化率**：導數項需要了解誤差變化的速度。透過將先前的誤差值儲存在鏈結串列中，我們可以精確計算誤差隨時間的變化 ($\frac{de(t)}{dt}$)：

$$
 dv = \frac{e(t) - preE}{dt}
$$

- **積分計算**：誤差積分隨時間累積，使控制器能夠回應與設定點的持續偏差：

$$
 intg += e(t) \times dt
$$

使用連結清單可以有效管理此錯誤歷史記錄。隨著新錯誤的添加，可以修剪舊條目以確保僅保留相關數據，這有助於避免過多的記憶體使用並使計算集中於系統的最新行為。

### 附加微分項

除了標準微分項 $K_d$ 之外，PID 控制器中還包含一個附加微分項 $K_{dd}$。此項表示二階導數分量，其定義如下：

$$
K_{dd} = K_d \times TddM
$$

其中：
- $TddM$ 是調整二階導數項影響的乘數。

包含 $K_{dd}$ 有助於控制器更有效預測誤差的變化。透過考慮誤差的加速度（即誤差的速率如何）。如果誤差變化本身也在變化），這個附加項增強了控制器的阻尼特性，允許更精細的控制響應，特別是在受到快速變化或振盪的系統中。

### 程式碼結構

#### 資料結構

- **Data**：保存時間差（`dt`）和誤差值（`e`）。
- **Node**：表示鏈結串列中的一個元素，包含`Data`和指向前一個節點的指標。
- **List**：管理鏈結串列，保存指向頭尾節點的指標以及鏈結串列的大小。

#### PID 類

`PID`類別封裝了PID控制邏輯。它包括：

- **成員變數**：
 - 控制增益：`Kp`、`Ki`、`Kd`、`Kdd`（附加導數項）。
 - 狀態變數：`preE`、`preDv`、`intg`、`preOut` 和 `preT` 分別用於儲存先前的錯誤、導數、積分項、最後的輸出和最後的時間戳記。
 - `dtXs`：`List` 的實例，用於維護歷史錯誤資料。

- **建構子**：初始化PID參數與狀態變數。

- **更新方法**：
 - 取得目前錯誤和時間戳，計算控制輸出，並更新內部狀態。
 - 實現用於計算自適應增益、管理錯誤歷史記錄和產生控制訊號的邏輯。

## testCar.hpp

### 概述

此頭檔包括用於模擬汽車運動的 `Car` 類別、用於根據與領先汽車的距離調整自動跟隨卡丁車速度的 PID 控制器，以及用於資料處理和結果管理的多個實用函數。

### 汽車類

`Car` 類別代表具有基本運動動力學的簡單車輛模型。它包括速度和位置的屬性，以及更新這些屬性的方法。

### PID調試功能

`pidDebug` 函數是用來記錄與 PID 控制操作相關的訊息的實用程式。

### 最後平方值的總和
```cpp
double sum_last_squared(const std::vector<double> &v, double prop)
```
計算所提供向量 `v` 的最後一個 `n * prop` 元素的平方和。

### 速度生成
```cpp
vector<double> velocities(int steps)
```
在指定數量的模擬步驟上產生速度值向量，模擬運動的不同階段（加速、減速和調整）。

### PID測試功能
```cpp
vector<double> test(double maxIntTm, double maxAmp, double minKp, double maxKp, double rTiM, double TdM, double TddM, double eDPm, double eDPa, unsigned long session, double Kp, double preE = 0, unsigned long preT = 0, double timeInterval = 10, int steps = 1000)
```
此功能模擬領頭車和自動跟隨卡丁車之間的交互，使用 PID 控制器根據與領頭車的距離調整跟隨車的速度。

- **參數**：
 - `double maxIntTm`：最大積分時間常數。
 - `double maxAmp`：控制輸出的最大振幅。
 - `double minKp`：最小比例增益。
 - `double maxKp`：最大比例增益。
 - `double rTiM`：參考時間間隔乘數。
 - `double TdM`：微分時間乘數。
 - `double TddM`：二階導數時間乘數。
 - `double eDPm`：最大誤差導數比例因子。
 - `double eDPa`：誤差導數調整因子。
 - `unsigned long session`：用於記錄目的的會話標識符。
 - `double Kp`：初始比例增益。
 - `double preE`：先前的錯誤值（可選，預設為 0）。
 - `unsigned long preT`：先前的時間值（可選，預設為 0）。
 - `double timeInterval`：模擬每一步的時間間隔（預設為10）。
 - `int steps`：模擬步驟總數（預設為 1000）。

- **返回**：包含領導者和追隨者之間隨時間變化的距離的向量。

### PID 測試資料結構
```cpp
struct pidTest
{
	double maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa;
	unsigned long session;
	double Kp, result;
};
```
`pidTest` 結構用於儲存 PID 測試的參數以及模擬結果。

### 結果寫入功能
```cpp
bool write_results(const vector<pidTest> &data, const string &filename)
```
將 PID 測試結果寫入 CSV 檔案以供分析。

### `ParameterRange`

定義優化參數範圍的結構。

- **屬性**：
 - `double start`：參數範圍的起始值。
 - `double end`：參數範圍的結束值。
 - `double step`：參數的增量步長。

## optimization.hpp

此頭檔定義了最佳化函數和結構，用於在不具有多執行緒處理的汽車模擬中最佳化 PID 控制器的參數。

### `int optimize(vector<ParameterRange> ranges)`

根據提供的範圍優化 PID 控制器的參數，並將結果寫入 CSV 檔案。

- **參數**：
 - `vector<ParameterRange> range`：包含要最佳化的參數範圍的向量。

- **返回**：
 - `int`：如果最佳化成功完成，則傳回`EXIT_SUCCESS` (0)，否則傳回`EXIT_FAILURE`。
 
 ## optimization_multithread.hpp

此頭檔定義了最佳化函數和結構，用於在具有多執行緒處理的汽車模擬中最佳化 PID 控制器的參數。

### `int optimize(vector<ParameterRange> ranges)`

根據提供的範圍優化 PID 控制器的參數，並將結果寫入 CSV 檔案。

- **參數**：
 - `vector<ParameterRange> range`：包含要最佳化的參數範圍的向量。

- **返回**：
 - `int`：如果最佳化成功完成，則傳回`EXIT_SUCCESS` (0)，否則傳回`EXIT_FAILURE`。

## main.cpp

此程式碼檔案示範如何使用 `optimization.hpp` （或`optimization_multithread.hpp`）頭檔來執行 PID 控制器的參數最佳化。它定義了一組參數範圍並呼叫 `optimize` 函數來評估不同的參數組合。

## 木板

木板作為跟隨卡丁車的支撐結構，連接並支撐 Arduino 板、全向輪、麵包板、2 個輪子和 2 個馬達等組件。

3D 設計檔案為 [assets/board.step](assets/board.step)。

這是切割木板的照片：

![assets/board.jpg](assets/board.jpg)

## 靈感和背景

此 PID（比例-積分-微分）控制器專案的開發植根於控制理論，這是一個關注動態系統行為的工程領域。讓我們主動出擊的是我們生活科技課上的自動跟隨卡丁車課。我們的目標是使用 Arduino 和木板從頭開始製作一輛自動跟隨卡丁車，並在有限的預算內盡可能提高品質。

### 控制理論與 PID 控制器

此 PID（比例-積分-微分）控制器專案的開發植根於控制理論，這是一個關注動態系統行為的工程領域。 PID 控制器是現代控制系統的基石。它們旨在根據回饋自動調整系統輸出，以最大限度地減少誤差，從而實現動態系統的精確控制。 PID 控制器基於三個基本組件運作：

1. **比例控制 (P)**：按比例回應目前誤差值，根據系統距離所需狀態的距離提供即時修正。

2. **積分控制 (I)**：解決過去累積的錯誤，確保系統即使有持續偏差也能達到所需狀態。

3. **微分控制（D）**：根據誤差的變化率預測未來的誤差，提供阻尼效應以減少超調和振盪。

這些參數的調整對於實現最佳性能至關重要。傳統的 Ziegler-Nichols 整定方法已成為許多工程師的基本方法，為根據系統行為設定 PID 參數提供了經驗指導。

### 生活科技課堂中的 Arduino 場景

Arduino 板為學生和業餘愛好者提供了一個易於訪問的平台，可以試驗硬體和軟體集成，從而促進技術課程中的實踐學習體驗。

在生活科技課程中，我們使用 Arduino 來建立需要即時控制系統的自動跟隨卡丁車專案。此場景凸顯了調整 PID 控制器以實現機器人和汽車系統所需行為的重要性。

這個 PID 控制器是我們的自動跟隨卡丁車的重要組成部分。我們用它來實現自動跟隨卡丁車和領頭卡丁車（在我們的例子中是清潔機器人）之間的穩定距離。

## 發展歷程

PID 控制器及其相關模擬框架的開發是一個迭代過程，其特點是不斷增強和改進細化。

### 初步實施

整個旅程從傳統 PID 控制器的簡單實作開始。重點是用 C++ 建立封裝 PID 邏輯的基本類別結構，以便在模擬中直接應用。

- **主要特點**：
 - 基本 PID 計算。
 - 透過條件編譯初步支援 Arduino 和非 Arduino 環境。

### 增強功能和自適應功能

在測試最初的實現時，一些限制變得明顯，特別是在響應能力和穩定性方面。這促使了高級功能的結合，例如：

- **自適應增益調整**：受動態反應需求的啟發，比例增益 $K_p$ 可根據誤差的變化率進行調整。此增強功能可以更好地處理系統中的瞬態行為。

- **自適應積分項**：為了減輕積分飽和，根據觀察到的誤差幅度調整積分增益 $K_i$。此功能提高了持續錯誤情況下的系統穩定性。

### 錯誤歷史管理

為了準確計算積分項和導數項，實施了強大的錯誤歷史管理系統。該系統利用鏈結串列結構來儲存過去的誤差值和時間戳，從而能夠精確計算積分和導數分量。受既定控制理論實踐的啟發，錯誤歷史管理的整合對於實施更高階的調整策略至關重要。

### 附加導數項

認識到需要改進阻尼特性，引入了額外的導數項 $K_{dd}$。該術語解釋了誤差變化的加速，使控制器能夠更有效地預測快速波動並對其做出反應。

### 測試和模擬框架

PID 邏輯到位後，注意力轉向建立全面的模擬框架來測試各種 PID 配置。用於模擬跟隨車輛和引導車輛的 `Car` 類別的引入為評估動態環境中的 PID 性能添加了實際背景。

- **PID測試功能**：開發了專用功能來模擬領先卡丁車和跟隨卡丁車之間的交互，從而深入了解不同的PID參數如何影響系統行為。

### 最佳化和多執行緒

為了方便進一步探索PID參數整定，整合了最佳化功能。利用多執行緒可以同時評估多個參數組合，大大提高了測試效率。優化框架還包括結果記錄和進度追蹤機制，使分析和視覺化結果變得更加容易。

## 貢獻

歡迎貢獻！如果您有改進或最佳化的想法，請分叉儲存庫並建立拉取請求。

## 執照

該項目根據 AGPL 許可證獲得許可。有關詳細信息，請參閱 [LICENSE.md](LICENSE.md) 文件。
