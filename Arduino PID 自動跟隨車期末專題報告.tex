\documentclass[a4paper,12pt]{report}
\usepackage[margin=1.27cm,foot=0.77cm]{geometry}
\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{3}
\newcounter{xeCJK}
\setcounter{xeCJK}{1}
\newcounter{Fonts}
\setcounter{Fonts}{1}
\newcounter{STIXMath}
\setcounter{STIXMath}{1}
\newcounter{CJKFonts}
\setcounter{CJKFonts}{1}
\newcounter{CJKLanguage}
\setcounter{CJKLanguage}{0}
\newcounter{NotoCJKFamily}
\setcounter{NotoCJKFamily}{0}
\newcounter{SectionLanguage}
\setcounter{SectionLanguage}{1}
\newcounter{ZhRenew}
\setcounter{ZhRenew}{1}
\input{/usr/share/latex-toolkit/template.tex}
\begin{document}
\title{
\Large 113 學年度第一學期工程設計科\\
\huge Arduino PID 自動跟隨車期末專題報告\\
\Large 113 Academic Year 1st Semester Engineering Design Course\\
\huge Arduino PID Auto-Following Kart Final Project Report
}
\author{30602王品翔\\30608沈威宇\\30627廖宏璿}
\date{\temtoday}
\titletocdoc
\section{致老師}
親愛的 溫老師敬和：\\\\
對於未能及時完全達成公開測試與封閉測試的標準，以及以英語呈現這份專題報告的許多部分，我們深感抱歉。\\\\
首先，我們了解這份專案需要大量軟硬體調適與修正，也誠摯希望能夠完成這個有益於我們求學和職涯的專案，但礙於學測與段考等時間壓力，我們僅完成軟硬體的設計與組裝，未能完成最後的調適封測，實在抱歉與可惜。\\\\
次者，雖然我了解全數使用中文更具有連貫性並有助於您的閱讀，但軟體開發、\LaTeX{} 與控制理論的技術內容資源以英文較充足，故以英文呈現許多部分，對於由此給您帶來的不便，我深表歉意。\\\\
感謝您在二年來課程中的諄諄教誨和耐心支持。
\nthm\section{Preparations}
\subsection{Initial Attempts}
The project initially explored the creation of a 3D design to visualize the concept and aid in prototyping. Using FreeCAD package in Python3, an early model was constructed and aimed to provide a tangible understanding of possible designs and test the performance of our kart. This model is latter abandoned after we got a rough understanding and consensus on the project and division of labor.
\subsubsection{3D Design}
\begin{lstlisting}[language=Python]
import FreeCAD, Part, Draft
from FreeCAD import Base

def create_wheel(radius, width, position):
    wheel = Part.makeCylinder(radius, width)
    wheel.translate(Base.Vector(position[0], position[1], position[2]))
    return wheel

def create_kart_body(length, width, height):
    body = Part.makeBox(length, width, height)
    return body

def create_kart_frame(length, width, height):
    frame = Part.makeBox(length, width, height)
    frame.translate(Base.Vector(0, 0, height / 2))      return frame

def create_arduino(length, width, height):
    arduino = Part.makeBox(length, width, height)
    arduino.translate(Base.Vector(10, 10, 0))      return arduino

def create_ultrasonic_sensor(length, width, height, position):
    sensor = Part.makeBox(length, width, height)
    sensor.translate(Base.Vector(position[0], position[1], position[2]))
    return sensor

def create_motor_controller(length, width, height, position):
    motor_controller = Part.makeBox(length, width, height)
    motor_controller.translate(Base.Vector(position[0], position[1], position[2]))
    return motor_controller

def create_rear_wheels():
    left_motor_wheel = create_wheel(30, 15, (40, 30, 0))      right_motor_wheel = create_wheel(30, 15, (40, -30, 0))      return left_motor_wheel, right_motor_wheel

def create_front_wheel():
    front_wheel = create_wheel(20, 10, (0, 0, 0))      return front_wheel
\end{lstlisting}
\subsubsection{Hardware Unit Test}
\begin{lstlisting}[language=Python]
import unittest
import FreeCAD
import Part
from FreeCAD import Base

def create_wheel(radius, width, position):
    wheel = Part.makeCylinder(radius, width)
    wheel.translate(Base.Vector(position[0], position[1], position[2]))
    return wheel

def create_kart_body(length, width, height):
    body = Part.makeBox(length, width, height)
    return body

def create_kart_frame(length, width, height):
    frame = Part.makeBox(length, width, height)
    frame.translate(Base.Vector(0, 0, height / 2))      return frame

def create_front_wheel():
    front_wheel = create_wheel(20, 10, (0, 0, 0))      return front_wheel

def create_kart():
        kart_body = create_kart_body(150, 80, 30)
    
        kart_frame = create_kart_frame(150, 80, 20)
    
        front_wheel = create_front_wheel()
    
        return [kart_body, kart_frame, front_wheel]

class TestKartModel(unittest.TestCase):
    def setUp(self):
        """Set up the environment for each test"""
        self.parts = create_kart()          self.kart_body = self.parts[0]
        self.kart_frame = self.parts[1]
        self.front_wheel = self.parts[2]

    def test_kart_body_dimensions(self):
        """Test the dimensions of the kart body"""
        length, width, height = 150, 80, 30
        self.assertEqual(self.kart_body.Length, length)
        self.assertEqual(self.kart_body.Width, width)
        self.assertEqual(self.kart_body.Height, height)

    def test_kart_frame_position(self):
        """Test the position of the kart frame"""
        expected_position = Base.Vector(0, 0, 10)          frame_position = self.kart_frame.CenterOfMass
        self.assertEqual(frame_position, expected_position)

    def test_front_wheel_position(self):
        """Test the position of the front wheel"""
        expected_position = Base.Vector(0, 0, 0)          wheel_position = self.front_wheel.CenterOfMass
        self.assertEqual(wheel_position, expected_position)

    def test_wheel_dimensions(self):
        """Test the dimensions of the front wheel"""
        radius, width = 20, 10
        wheel_radius = self.front_wheel.Radius
        wheel_width = self.front_wheel.Height
        self.assertEqual(wheel_radius, radius)
        self.assertEqual(wheel_width, width)

    def test_assembly(self):
        """Test if all components are assembled correctly"""
        self.assertIsInstance(self.kart_body, Part.Feature)
        self.assertIsInstance(self.kart_frame, Part.Feature)
        self.assertIsInstance(self.front_wheel, Part.Feature)
        self.assertEqual(len(self.parts), 3)  
        
if __name__ == '__main__':
    unittest.main()
\end{lstlisting}
\subsubsection{PID and Arduino Code}
\begin{lstlising}[language=C++]
#include <PID_v1.h>

#define LEFT_TRIGGER_PIN  2
#define LEFT_ECHO_PIN     3
#define RIGHT_TRIGGER_PIN 4
#define RIGHT_ECHO_PIN    5
#define MOTOR_LEFT_PIN    6
#define MOTOR_RIGHT_PIN   7

double Setpoint, Input, Output;
double Kp = 1.0, Ki = 0.1, Kd = 0.05; // PID constants, adjust based on testing

PID pid(&Input, &Output, &Setpoint, Kp, Ki, Kd, DIRECT);

long durationLeft, durationRight;
int distanceLeft, distanceRight;
int targetDistance = 20; // Target distance from obstacles (in cm)

int motorSpeed = 255; // Maximum speed (adjustable)
int minDistance = 10; // Minimum distance from the obstacle to stop motors

void setup() {
  pinMode(LEFT_TRIGGER_PIN, OUTPUT);
  pinMode(LEFT_ECHO_PIN, INPUT);
  pinMode(RIGHT_TRIGGER_PIN, OUTPUT);
  pinMode(RIGHT_ECHO_PIN, INPUT);

  pinMode(MOTOR_LEFT_PIN, OUTPUT);
  pinMode(MOTOR_RIGHT_PIN, OUTPUT);

  Serial.begin(9600);

  Setpoint = targetDistance;
  pid.SetMode(AUTOMATIC);
  pid.SetOutputLimits(-motorSpeed, motorSpeed); // Motor speed limit
}

void loop() {
  distanceLeft = getDistance(LEFT_TRIGGER_PIN, LEFT_ECHO_PIN);
  distanceRight = getDistance(RIGHT_TRIGGER_PIN, RIGHT_ECHO_PIN);

  Serial.print("Left Distance: ");
  Serial.print(distanceLeft);
  Serial.print(" cm | Right Distance: ");
  Serial.println(distanceRight);

  int error = distanceLeft - distanceRight;
  Input = error;

  pid.Compute();

  if (distanceLeft < minDistance || distanceRight < minDistance) {
    stopMotors();
  } else {
    moveForwardWithPID(Output);
  }

  delay(50); // Small delay to allow sensors to settle
}

int getDistance(int triggerPin, int echoPin) {
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);
  durationLeft = pulseIn(echoPin, HIGH);
  return durationLeft * 0.034 / 2;
}

void moveForwardWithPID(double pidOutput) {
  int leftMotorSpeed = motorSpeed - pidOutput;  // Adjust left motor speed
  int rightMotorSpeed = motorSpeed + pidOutput; // Adjust right motor speed
  
  leftMotorSpeed = constrain(leftMotorSpeed, 0, motorSpeed);
  rightMotorSpeed = constrain(rightMotorSpeed, 0, motorSpeed);

  analogWrite(MOTOR_LEFT_PIN, leftMotorSpeed);
  analogWrite(MOTOR_RIGHT_PIN, rightMotorSpeed);
}

void stopMotors() {
  analogWrite(MOTOR_LEFT_PIN, 0);
  analogWrite(MOTOR_RIGHT_PIN, 0);
}
\end{lstlisting}
\subsection{Division of Labor}
We divided each one's responsibility based on their expertise and experience.
\begin{itemize}
\item 王品翔 is an expert of 3D modeling and design of microprocessor development board driven bots and karts. He has experienced in CAD modelling, 3D printing, laser cutting, microprocessor development board software etc. and has won awards in Arduino or Cortex microprocessor development boards driven bots competitions. So he's the chef of 3D modelling, hardware designing, and components producing.
\item 沈威宇 specializes at programming and mark-up languages such as C and LaTeX and also good at advanced mathematics. He has been participating development of machine learning powered financial analysis and algorithmatic trading, Linux virtual machine on Android, microprocessor development board software etc. So he's responsible for PID control system developing, Arduino program developing, and project report making.
\item 廖宏璿 is also good at hardware and software development for microprocessor development board driven bots and karts and has participated development of active noise cancelling headphones. He is an expertise of physical structure carpentry and assembling, and wiring for microprocessor development boards and bread boards. So he's focused on design and practice of wiring, wood structure assembling, and parameter tuning.
\end{itemize}

\section{硬體設計、3D 建模與零件製造}
在這次的車輛設計中，我們以自然界的古老生物——鱟作為靈感來源，結合其生物學特性與流體力學特徵，打造出具有前瞻性與功能性的車輛外形與結構。鱟的流線型身體和穩定行走的構造，為我們提供了在設計中平衡美學與實用性的寶貴啟示。\\\\
由於跟隨車需要做到即時與大動作地加速與轉彎反饋，我們採用了前驅作為動力系統的核心設計，並在後輪設計採用了萬向滾珠技術，提高了車輛加速與轉彎時的性能，使車輛在移動時能夠實現靈活的大角度轉彎，增加動力使用效率，並保持配重穩定性。\\\\
這輛車的設計展現了我們對自然生物演化的體悟，也彰顯了我們對未來交通工具的遠見。通過模仿鱟的仿生設計結構，我們希望這樣的跟隨車設計可以具有提高機動性與增加適用場景的潛能，可以為載人、運貨、倉管、軍事、農業等潛在場景特化使用。
\ssc s
\bctf\icg{各圖片}\efct
\ssc s
\begin{lstlisting}各step檔案

\section{PID Controller, Software Simulation, Parameters Optimization, and Arduino Code}
I implemented a PID (Proportional-Integral-Derivative) controller designed to regulate the speed of the auto-following kart with a leader robot. The implementation includes the PID controller logic, a car simulation, a framework for testing various PID configurations, and the Arduino applications.
\subsection{PID.hpp}
This header file implements a PID controller that includes traditional PID control logic along with enhancements such as adaptive gain adjustment, adaptive integral term, error history management, and additional derivative term. It is also designed to be compatible with both Arduino and non-Arduino environments.
\subsubsection{Code}
\begin{lstlisting}[language=C++}
#ifndef PID_HPP
#define PID_HPP

#ifdef ARDUINO
#include <Arduino.h>
#include <math.h>
#define to_string(a) String(a)
#else
#include <cmath>
#include <string>
#define String string
using namespace std;
#endif
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define ABS(a) ((a) < 0 ? -(a) : (a))
#define COPYSIGN(a, b) ((b) < 0 ? -ABS(a) : ABS(a))
#define CLAMP(a, b, c) (MAX(MIN((a), (b)), (c)))

struct Data {
    unsigned long dt;
    double e;
};

struct Node {
    Data data;
    Node* prev;
};

struct List {
    Node* head;
    Node* tail;
    unsigned int size;
};

class PID {
public:
    const double maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa;
    const unsigned long session;
    double Kp, Ki, Kd, Kdd, preE, preDv, intg, preOut;
    unsigned long preT;
    List dtXs;

    PID(double maxIntTm, double maxAmp, double minKp, double maxKp, double rTiM, double TdM, double TddM, double eDPm, double eDPa, unsigned long session, double Kp, double preE=0, unsigned long preT=0)
        : maxIntTm(maxIntTm), maxAmp(maxAmp), minKp(minKp), maxKp(maxKp), rTiM(rTiM), TdM(TdM), TddM(TddM), eDPm(eDPm), eDPa(eDPa), session(session), Kp(Kp), Ki(0), Kd(0), Kdd(0), preE(preE), preDv(0), intg(0), preOut(0), preT(preT), dtXs({nullptr, nullptr, 0}) {}

    double update(double e, unsigned long timestamp, String* debug = nullptr) {
        unsigned long dt = timestamp - preT;
        preT = timestamp;

        if (dt == 0) {
            if (debug != nullptr) {
                *debug += "dt=0\n";
            }
            return preOut;
        }

        double amp, ap;

        if (session>0) {
                unsigned long S = 0;
                amp = 0;
                if (dtXs.size > 1) {
                    Node* pos = dtXs.tail;
                    while (dtXs.size > 1 && pos != nullptr) {
                        S += pos->data.dt;
                        amp = MAX(ABS(pos->data.e), amp);
                        if (S > session) {
                            dtXs.head = pos;
                            Node* cur = pos->prev;
                            pos->prev = nullptr;
                            while (cur != nullptr) {
                                Node* tmp = cur->prev;
                                delete cur;
                                cur = tmp;
                                dtXs.size--;
                            }
                            break;
                        } else pos = pos->prev;
                    }
                } else if (dtXs.size == 1) {
                    amp = ABS(dtXs.tail->data.e);
                }        
            ap = exp(-amp / maxAmp);
        } else {
            amp=0;
            ap=1;
        }

        Ki = Kp * rTiM * ap;
        Kd = Kp * TdM * ap;
        Kdd = Kd * TddM;

        double dv = (e - preE) / dt;
        double dd = (dv - preDv) / dt;

        intg += e * dt;
        double intTm = Ki * intg;
        if (ABS(intTm) > maxIntTm) {
            intg = COPYSIGN(maxIntTm / Ki, intTm);
            intTm = COPYSIGN(maxIntTm, intTm);
        }

        double propTm = Kp * e;
        double dvTm = Kd * dv;
        double ddTm = Kdd * dd;
        double out = propTm + intTm + dvTm + ddTm;

        double eDP = e * dv;
        if (ABS(eDP) > eDPm) {
            Kp *= (eDP < 0) ? (1+eDPa) : (1-eDPa);
            Kp = MIN(MAX(Kp, minKp), maxKp);
        }

        if (debug != nullptr) {
            *debug += "update() called\ndt: " + to_string(dt) + ", e: " + to_string(e) + ", dv: " + to_string(dv) + ", dd: " + to_string(dd) +", amp: " + to_string(amp) +", ap: " + to_string(ap) + ",\nKp: " + to_string(Kp) + ", Ki: " + to_string(Ki) + ", Kd: " + to_string(Kd) + ", Kdd: " + to_string(Kdd) + ",\npropTm: " + to_string(propTm) + ", intTm: " + to_string(intTm) + ", dvTm: " + to_string(dvTm) + ", ddTm: " + to_string(ddTm) + ",\neDP: " + to_string(eDP) + ", out: " + to_string(out) + "\n";
        }

        preE = e;
        preDv = dv;
        preOut = out;

        if (session>0) {
            Node* nn = new Node{{dt, e}, dtXs.tail};
            dtXs.tail = nn;
            if (dtXs.size == 0) dtXs.head = nn;
            dtXs.size++;
       } 

        return out;
    }
};

#endif
\end{lstlisting}
\subsubsection{Arduino and Non-Arduino Compatibility}
The header is designed to be compatible with both Arduino and non-Arduino environments. This allows developers to use the same PID controller implementation across different platforms.\\
Conditional Compilation:
\begin{lstlisting}[language=C++]
#ifdef ARDUINO
#include <Arduino.h>
#include <math.h>
#define to_string(a) String(a)
#else
#include <cmath>
#include <string>
#define String string
using namespace std;
#endif
\end{lstlising}
\subsubsection{Traditional PID Controller}
The traditional PID controller is defined by the following equation:
$$
u(t) = K_p e(t) + K_i \int_0^t e(\tau) \,\mathrm{d}\tau + K_d \frac{\mathrm{d}e(t)}{\mathrm{d}t},
$$
where:
\begin{itemize}
\item $u(t)$ is the control output.
\item $e(t)$ is the error at time $t$, defined as the difference between the desired value and the measured value.
\item $K_p$, $K_i$, and $K_d$ are the proportional, integral, and derivative gains, respectively.
\end{itemize}
\subsubsection{Adaptive Gain Adjustment}
The proportional gain $K_p$ is dynamically adjusted based on the interaction between the current error $e(t)$ and its rate of change (derivative). This adjustment is designed to improve the responsiveness of the controller to changing conditions. The adaptation can be mathematically expressed as follows:
$$
K_p' = K_p \times (1 \pm eDP_a),
$$
where:
\begin{itemize}
\item $eDP = e(t) \times \frac{de(t)}{dt}$
\item $eDP_m$ is a threshold that determines when to adjust the proportional gain.
\item $eDP_a$ is the adjustment factor that scales the change in $K_p$ based on the error’s derivative. 
\end{itemize}
The key idea behind this adjustment is to increase the proportional gain when the system is experiencing a large error combined with a significant rate of change, which could indicate an approaching overshoot or oscillation. Conversely, if the error is decreasing but remains large, it may reduce the proportional gain to prevent excessive correction, allowing the system to stabilize more smoothly.
\subsubsection{Adaptive Integral Term}
Integral control is essential for eliminating steady-state error; however, it can lead to issues like integral windup, where the integral term accumulates excessively during periods of sustained error. To mitigate this, the integral gain $K_i$ is adaptively computed as follows:
$$
K_i = K_p \times rTiM \times ap
$$
Where:
\begin{itemize}
\item $ap = e^{-\frac{\text{amp}}{\text{maxAmp}}}$
\item $rTiM$ is a constant that relates to the desired integral time constant.
\end{itemize}
The variable $amp$ represents the maximum amplitude of error observed over a session. By using the exponential decay factor $ap$, the contribution of the integral term is diminished during periods of high error, effectively reducing the risk of windup. When the error is within an acceptable range, $ap$ approaches 1, allowing the integral term to contribute effectively to the control output.
\subsubsection{Error History Management}
Inspired by the \textbf{Ziegler–Nichols tuning method}, the implementation maintains a history of past errors and their timestamps to calculate the derivative and integral terms accurately. This history management is crucial for two main reasons:
\begin{itemize}
\item \textbf{Deriving the Rate of Change}: The derivative term requires knowledge of how fast the error is changing. By storing previous error values in a linked list, we can accurately compute the change in error over time ($\frac{de(t)}{dt}$):
$$
  dv = \frac{e(t) - preE}{dt}
$$
\item \textbf{Integral Calculation}: The integral of the error is accumulated over time, enabling the controller to respond to persistent deviations from the setpoint:
$$
  intg += e(t) \times dt
$$
\end{itemize}
Using a linked list allows for efficient management of this error history. As new errors are added, older entries can be pruned to ensure that only relevant data is retained, which helps avoid excessive memory usage and keeps the calculations focused on the most recent behavior of the system.
\subsubsection{Additional Derivative Term}
In addition to the standard derivative term $K_d$, an additional derivative term $K_{dd}$ is included in the PID controller. This term represents a second derivative component, which can be defined as follows:
$$
K_{dd} = K_d \times TddM,
$$
where $TddM$ is a multiplier that adjusts the impact of the second derivative term. \\
The inclusion of $K_{dd}$ helps the controller anticipate changes in the error more effectively. By accounting for the acceleration of the error (i.e., how the rate of error change is itself changing), this additional term enhances the damping characteristics of the controller, allowing for more refined control responses, especially in systems that are subject to rapid changes or oscillations.
\subsubsection{Data Structures}
\begin{itemize}
\item \textbf{Data}: Holds the time difference (\texttt{dt}) and error value (\texttt{e}).
\item \textbf{Node}: Represents an element in the linked list, containing \texttt{Data} and a pointer to the previous node.
\item \textbf{List}: Manages the linked list, holding pointers to the head and tail nodes and the size of the list.
\end{itemize}
\subsubsection{PID Class}
The \texttt{PID} class encapsulates the PID control logic. It includes:
\begin{itemize}
\item \textbf{Member Variables:}
\begin{itemize}
\item Control gains: $K_p$, $K_i$, $K_d$, $K_{dd}$ (additional derivative term).
\item State variables: \texttt{preE}, \texttt{preDv}, \texttt{intg}, \texttt{preOut}, and \texttt{preT}, which store the previous error, derivative, integral term, last output, and last timestamp, respectively.
\item \texttt{dtXs}: An instance of \texttt{List} to maintain historical error data.
\end{itemize}
\item \textbf{Constructor:} Initializes the PID parameters and state variables.
\item \textbf{Update Method:}
\begin{itemize}
\item Takes the current error and timestamp, computes the control output, and updates the internal state.
\item Implements logic for calculating the adaptive gains, managing error history, and generating the control signal.
\end{itemize}
\end{itemize}
\subsection{testCar.hpp}
This header file includes a \texttt{Car} class for simulating the motion of a car, a PID controller for adjusting the speed of an auto-following kart based on the distance to a leader car, and several utility functions for data processing and results management.
\subsubsection{Code}
\begin{lstlising}[language=C++]
#ifndef TESTCAR_HPP
#define TESTCAR_HPP

#include <iostream>
#include <cmath>
#include <string>
#include <vector>
#include <numeric>
#include <fstream>
#include <algorithm>
#include "PID.hpp"
using namespace std;

class Car
{
  public:
        Car(double initialSpeed, double initialPosition)
                : speed(initialSpeed), position(initialPosition) {}

        void updatePosition(double timeInterval)
        {
                position += speed * timeInterval;
        }

        void changeSpeed(double newSpeed)
        {
                speed = newSpeed;
        }

        double getPosition() const
        {
                return position;
        }

        double getSpeed() const
        {
                return speed;
        }

        double speed;
        double position;
};

void pidDebug(string message)
{
        cout << message;
}

double sum_last_squared(const std::vector<double> &v, double prop)
{
        if (v.empty())
                return 0.0;

        size_t n = v.size();
        size_t count = static_cast<size_t>(std::ceil(n * prop));
        size_t start_index = n - count;

        double sum_of_squares = std::accumulate(v.begin() + start_index, v.end(), 0.0,
                                                                                        [](double sum, double value) {
                                                                                                return sum + value * value;
                                                                                        });
        return sum_of_squares;
}

vector<double> velocities(int steps)
{
        vector<double> velocities(steps, 0.0);
        double acceleration = 1;
        double error = 0.2;

        int phase_length = steps / 6;
        double velocity = 0.0;

        for (int i = 0; i < phase_length; ++i)
        {
                velocity += acceleration + ((i % 3 == 0) ? error : ((i % 3 == 1) ? (-error) : 0));
                velocities[i] = velocity;
        }

        for (int i = phase_length; i < 2 * phase_length; ++i)
        {
                velocity += ((i % 3 == 0) ? error : ((i % 3 == 1) ? (-error) : 0));
                velocities[i] = velocity;
        }

        for (int i = 2 * phase_length; i < 4 * phase_length; ++i)
        {
                velocity -= acceleration + ((i % 3 == 0) ? error : ((i % 3 == 1) ? (-error) : 0));
                velocities[i] = velocity;
        }

        for (int i = 4 * phase_length; i < 5 * phase_length; ++i)
        {
                velocity += acceleration + ((i % 3 == 0) ? error : ((i % 3 == 1) ? (-error) : 0));
                velocities[i] = velocity;
        }

        for (int i = 5 * phase_length; i < steps; ++i)
        {
                if (ABS(velocity) >= (error * (steps - i)))
                {
                        velocity += COPYSIGN(velocity, error);
                }
                else
                {
                        velocity += ((i % 3 == 0) ? error : ((i % 3 == 1) ? (-error) : 0));
                }
                velocities[i] = velocity;
        }

        return velocities;
}

vector<double> test(double maxIntTm, double maxAmp, double minKp, double maxKp, double rTiM, double TdM, double TddM, double eDPm, double eDPa, unsigned long session, double Kp, double preE = 0, unsigned long preT = 0, double timeInterval = 10, int steps = 50, bool debug = false)
{
        double leaderInitialSpeed = 0;
        double followerInitialSpeed = 0;
        double initialDistance = 0;

        vector<double> vec;
        vector<double> vol = velocities(steps);

        Car leader(leaderInitialSpeed, initialDistance);
        Car follower(followerInitialSpeed, 0);

        PID pid = PID(maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa, session, Kp, preE, preT);

        cout << fixed << setprecision(4);

        for (int i = 0; i < steps; i++)
        {
                leader.changeSpeed(leader.getSpeed() + vol[i]);
                leader.updatePosition(timeInterval);
                follower.updatePosition(timeInterval);

                double distanceToLeader = leader.getPosition() - follower.getPosition();
                vec.push_back(distanceToLeader);
                string* ptr = nullptr;
                if (debug) {
            cout << "TimeStep: " << i << ", distanceToLeader: " << distanceToLeader << ", FollowerSpeed: " << follower.getSpeed() << ", LeaderSpeed: " << leader.getSpeed() << "\n";

                    ptr = new string;
                }
                double fS = pid.update(distanceToLeader, i * timeInterval, ptr);
                follower.changeSpeed(follower.getSpeed() + MAX(-511, MIN(fS, 511)));
                if (debug) {
            cout << *ptr;
                    delete ptr;
                }
        }

        return vec;
}

struct pidTest
{
        double maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa;
        unsigned long session;
        double Kp, result;
};

bool write_results(const vector<pidTest> &data, const string &filename)
{
        auto sorted_data = data;
        sort(sorted_data.begin(), sorted_data.end(), [](const pidTest &a, const pidTest &b) {
                return a.result < b.result;
        });

        ofstream outfile(filename);
        if (!outfile)
        {
                cerr << "Error opening file for writing." << endl;
                return 0;
        }

        outfile << "maxIntTm,maxAmp,minKp,maxKp,rTiM,TdM,TddM,eDPm,eDPa,session,Kp,result\n";

        for (size_t i = 0; i < sorted_data.size(); ++i)
        {
                const pidTest &pt = sorted_data[i];
                outfile << pt.maxIntTm << "," << pt.maxAmp << "," << pt.minKp << "," << pt.maxKp << ","
                                << pt.rTiM << "," << pt.TdM << "," << pt.TddM << "," << pt.eDPm << "," << pt.eDPa << ","
                                << pt.session << "," << pt.Kp << "," << pt.result << "\n";
        }

        outfile.close();
        cout << "Data written to " << filename << endl;

        return 1;
}

struct ParameterRange
{
        double start;
        double end;
        double step;
};

#endif
\end{lstlisting}
\subsubsection{Car Class}
The \texttt{Car} class represents a simple vehicle model with basic motion dynamics. It includes attributes for speed and position, as well as methods to update these attributes.
\subsubsection{PID Debugging Function}
The \texttt{pidDebug} function is a utility for logging messages related to PID control operations.
\subsubsection{Sum of Last Squared Values}
\begin{lstlisting}[language=cpp]
double sum_last_squared(const std::vector<double> &v, double prop)
\end{lstlisting}
Calculates the sum of squares of the last $n \times \text{prop}$ elements of the provided vector \texttt{v}.
\subsubsection{Velocity Generation}
\begin{lstlisting}[language=cpp]
vector<double> velocities(int steps)
\end{lstlisting}
Generates a vector of velocity values over a specified number of simulation steps, simulating different phases of motion (acceleration, deceleration, and adjustments).
\subsubsection{PID Testing Function}
\begin{lstlisting}[language=cpp]
vector<double> test(double maxIntTm, double maxAmp, double minKp, double maxKp, double rTiM, double TdM, double TddM, double eDPm, double eDPa, unsigned long session, double Kp, double preE = 0, unsigned long preT = 0, double timeInterval = 10, int steps = 1000)
\end{lstlisting}
This function simulates the interaction between a leader car and an auto-following kart using a PID controller to adjust the follower's speed based on the distance to the leader.
\begin{itemize}
\item \textbf{Parameters:}
\begin{itemize}
\item \texttt{double maxIntTm}: Maximum integral time constant.
\item \texttt{double maxAmp}: Maximum amplitude of control output.
\item \texttt{double minKp}: Minimum proportional gain.
\item \texttt{double maxKp}: Maximum proportional gain.
\item \texttt{double rTiM}: Reference time interval multiplier.
\item \texttt{double TdM}: Derivative time multiplier.
\item \texttt{double TddM}: Second derivative time multiplier.
\item \texttt{double eDPm}: Maximum error derivative proportionality factor.
\item \texttt{double eDPa}: Error derivative adjustment factor.
\item \texttt{unsigned long session}: Session identifier for logging purposes.
\item \texttt{double Kp}: Initial proportional gain.
\item \texttt{double preE}: Previous error value (optional, defaults to 0).
\item \texttt{unsigned long preT}: Previous time value (optional, defaults to 0).
\item \texttt{double timeInterval}: Time interval for each step of simulation (default is 10).
\item \texttt{int steps}: Total number of simulation steps (default is 1000).
\end{itemize}
\item \textbf{Returns:} A vector containing the distances between the leader and follower over time.
\end{itemize}
\subsubsection{PID Test Data Structure}
\begin{lstlisting}[language=cpp]
struct pidTest
{
double maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa;
unsigned long session;
double Kp, result;
};
\end{lstlisting}
The \texttt{pidTest} structure is used to store parameters for PID testing, along with the result of the simulation.
\subsubsection{Result Writing Function}
\begin{lstlisting}[language=cpp]
bool write_results(const vector<pidTest> &data, const string &filename)
\end{lstlisting}
Writes the results of PID tests to a CSV file for analysis.
\subsubsection{ParameterRange}
A structure to define the range of parameters for optimization.
\begin{itemize}
\item \textbf{Attributes:}
\begin{itemize}
\item \texttt{double start}: The starting value of the parameter range.
\item \texttt{double end}: The ending value of the parameter range.
\item \texttt{double step}: The increment step for the parameter.
\end{itemize}
\end{itemize}
\subsection{optimization.hpp}
This header file defines the optimization functions and structures used to optimize the parameters of a PID controller in a car simulation without multi-threaded processing.
\subsubsection{Code}
\begin{lstlising}[language=C++]
#ifndef OPTIMIZATION_HPP
#define OPTIMIZATION_HPP

#include "testCar.hpp"
using namespace std;

int optimize(vector<ParameterRange> ranges)
{
    vector<pidTest> results;

        for (double maxIntTm = ranges[0].start; maxIntTm <= ranges[0].end; maxIntTm += ranges[0].step)
        {
                for (double maxAmp = ranges[1].start; maxAmp <= ranges[1].end; maxAmp += ranges[1].step)
                {
                        for (double minKp = ranges[2].start; minKp <= ranges[2].end; minKp += ranges[2].step)
                        {
                                for (double maxKp = max(minKp, ranges[3].start);
                                         maxKp <= ranges[3].end; maxKp += ranges[3].step)
                                {
                                        for (double rTiM = ranges[4].start; rTiM <= ranges[4].end; rTiM += ranges[4].step)
                                        {
                                                for (double TdM = ranges[5].start; TdM <= ranges[5].end; TdM += ranges[5].step)
                                                {
                                                        for (double TddM = ranges[6].start; TddM <= ranges[6].end; TddM += ranges[6].step)
                                                        {
                                                                for (double eDPm = ranges[7].start; eDPm <= ranges[7].end; eDPm += ranges[7].step)
                                                                {
                                                                        for (double eDPa = ranges[8].start; eDPa <= ranges[8].end; eDPa += ranges[8].step)
                                                                        {
                                                                                for (unsigned long session = ranges[9].start; session <= ranges[9].end; session += ranges[9].step)
                                                                                {
                                                                                        for (double Kp = MAX(minKp, ranges[10].start);
                                                                                                 Kp <= MIN(maxKp, ranges[10].end); Kp += ranges[10].step)
                                                                                        {
                                                                                                vector<double> tmp = test(maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa, session, Kp);
                                                                                                double result = sum_last_squared(tmp, 0.5);
                                                                                                results.push_back(pidTest({maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa, session, Kp, result}));
                                                                                        }
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        if (!write_results(results, "results.csv"))
        {
                cerr << "Error writing results to file." << endl;
                return EXIT_FAILURE;
        }

        return EXIT_SUCCESS;
}

#endif
\end{lstlising}
\subsubsection{Optimize Function}
Optimizes the parameters of the PID controller based on the provided ranges and writes results to a CSV file.
\begin{itemize}
\item \textbf{Parameters:}
\begin{itemize}
\item \texttt{vector<ParameterRange> ranges}: A vector containing the ranges of parameters to optimize.
\end{itemize}
\item \textbf{Returns:}
\begin{itemize}
\item \texttt{int}: Returns \texttt{EXIT\_SUCCESS} (0) if optimization completes successfully, otherwise returns \texttt{EXIT\_FAILURE}.
\end{itemize}
\end{itemize}
\subsection{optimization\_multithread.hpp}
This header file defines the optimization functions and structures used to optimize the parameters of a PID controller in a car simulation with multi-threaded processing.
\begin{lstlising}[language=C++]
#ifndef OPTIMIZATION_MULTITHREAD_HPP
#define OPTIMIZATION_MULTITHREAD_HPP

#include <vector>
#include <iostream>
#include <thread>
#include <mutex>
#include <queue>
#include <atomic>
#include <chrono>
#include <iomanip>
#include <condition_variable>
#include <cmath>
#include "testCar.hpp"
using namespace std;

mutex resultsMutex;
mutex queueMutex;
atomic<int> totalCombinations(0);
atomic<int> processedCombinations(0);
queue<vector<double>> parameterQueue;
condition_variable cv;

void displayProgress()
{
        while (true)
        {
                {
                        lock_guard<mutex> lock(queueMutex);
                        if (processedCombinations >= totalCombinations)
                        {
                                break;
                        }
                        cout << "\rProgress: " << processedCombinations << "/" << totalCombinations
                                 << " (" << fixed << setprecision(2)
                                 << (static_cast<double>(processedCombinations) / totalCombinations * 100)
                                 << "%)          " << flush;
                }
                this_thread::sleep_for(chrono::seconds(1));
        }
        cout << "\rProgress: 100% Complete!                   " << endl;
}

size_t calculateSteps(const ParameterRange &range)
{
        return static_cast<size_t>(ceil((range.end - range.start) / range.step)) + 1;
}

void workerFunction(vector<pidTest> &results, atomic<bool> &running)
{
    while (running)
    {
        vector<double> params;

        {
            unique_lock<mutex> lock(queueMutex);
            cv.wait(lock, [] { return !parameterQueue.empty(); });
            if (parameterQueue.empty())
            {
                continue;
            }
            params = parameterQueue.front();
            parameterQueue.pop();
        }

        vector<double> tmp = test(
            params[0], params[1], params[2], params[3],
            params[4], params[5], params[6], params[7],
            params[8], params[9], params[10]);

        double result = sum_last_squared(tmp, 0.5);

        {
            lock_guard<mutex> lock(resultsMutex);
            results.emplace_back(pidTest{
                params[0], params[1], params[2], params[3],
                params[4], params[5], params[6], params[7],
                params[8], static_cast<unsigned long>(params[9]),
                params[10], result});
        }

        processedCombinations++;
        cv.notify_one();
    }
}

int optimize(vector<ParameterRange> ranges)
{
        totalCombinations = 1;
        for (const auto &range : ranges)
        {
                size_t steps = calculateSteps(range);
                if (totalCombinations > 0 && steps > SIZE_MAX / totalCombinations)
                {
                        cerr << "Error: Too many combinations, would cause overflow" << endl;
                        return 1;
                }
                totalCombinations = totalCombinations * steps;
        }

        cout << "Total parameter combinations to test: " << totalCombinations << endl;

        for (double maxIntTm = ranges[0].start; maxIntTm <= ranges[0].end; maxIntTm += ranges[0].step)
        {
                for (double maxAmp = ranges[1].start; maxAmp <= ranges[1].end; maxAmp += ranges[1].step)
                {
                        for (double minKp = ranges[2].start; minKp <= ranges[2].end; minKp += ranges[2].step)
                        {
                                for (double maxKp = max(minKp, ranges[3].start);
                                         maxKp <= ranges[3].end; maxKp += ranges[3].step)
                                {
                                        for (double rTiM = ranges[4].start; rTiM <= ranges[4].end; rTiM += ranges[4].step)
                                        {
                                                for (double TdM = ranges[5].start; TdM <= ranges[5].end; TdM += ranges[5].step)
                                                {
                                                        for (double TddM = ranges[6].start; TddM <= ranges[6].end; TddM += ranges[6].step)
                                                        {
                                                                for (double eDPm = ranges[7].start; eDPm <= ranges[7].end; eDPm += ranges[7].step)
                                                                {
                                                                        for (double eDPa = ranges[8].start; eDPa <= ranges[8].end; eDPa += ranges[8].step)
                                                                        {
                                                                                for (unsigned long session = ranges[9].start; session <= ranges[9].end; session += ranges[9].step)
                                                                                {
                                                                                        for (double Kp = MAX(minKp, ranges[10].start);
                                                                                                 Kp <= MIN(maxKp, ranges[10].end); Kp += ranges[10].step)
                                                                                        {
                                                                                                parameterQueue.push(pidTest({maxIntTm, maxAmp, minKp, maxKp, rTiM, TdM, TddM, eDPm, eDPa, session, Kp}));
                                                                                        }
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }

        vector<pidTest> results;
        vector<thread> threads;
        atomic<bool> running(true);

        thread progressThread(displayProgress);
        unsigned int numThreads = thread::hardware_concurrency();
        cout << "Using " << numThreads << " threads" << endl;

        for (unsigned int i = 0; i < numThreads; ++i)
        {
                threads.emplace_back(workerFunction, ref(results), ref(running));
        }

        for (auto &thread : threads)
        {
                thread.join();
        }

        running = false;
        cv.notify_all();

        progressThread.join();

        if (!write_results(results, "results.csv"))
        {
                cerr << "Error writing results to file." << endl;
                return EXIT_FAILURE;
        }

        return EXIT_SUCCESS;
}

#endif
\end{lstlisting}
\subsubsection{Optimize Function}
Optimizes the parameters of the PID controller based on the provided ranges and writes results to a CSV file.
\begin{itemize}
\item \textbf{Parameters:}
\begin{itemize}
\item \texttt{vector<ParameterRange> ranges}: A vector containing the ranges of parameters to optimize.
\end{itemize}
\item \textbf{Returns:}
\begin{itemize}
\item \texttt{int}: Returns \texttt{EXIT\_SUCCESS} (0) if optimization completes successfully, otherwise returns \texttt{EXIT\_FAILURE}.
\end{itemize}
\end{itemize}
\subsection{main.cpp}
The code file demonstrates the usage of the \texttt{optimization.hpp} (or \texttt{optimization\_multithread.hpp}) header file to perform parameter optimization for a PID controller. It defines a set of parameter ranges and calls the \texttt{optimize} function to evaluate different combinations of parameters.
\subsubsection{Code}
\begin{lstlisting}[language=C++]
#include "optimization.hpp" // or #include "optimization_multithread.hpp"

int main() {
    // Note that steps can't be zero
    vector<ParameterRange> ranges = {
        {461.9, 461.9, 1},    // maxIntTm
        {517.9, 517.9, 1},     // maxAmp
        {0.00265, 0.00265, 1},       // minKp
        {0.472, 0.472, 1},      // maxKp
        {1, 1, 1},       // rTiM
        {65.37, 65.37, 1},       // TdM
        {1.7, 1.7, 1},        // TddM
        {125, 125, 1}, // eDPm
        {0.15, 0.15, 1},    // eDPa
        {140, 140, 10},       // session
        {0.2436, 0.2436, 1}      // Kp
    };

    return optimize(ranges);
}
\end{lstlisting}
\subsubsection{Notes}
Note that steps can't be zero or the program won't stop.
\subsection{main.ino}
This Arduino code is for controlling a differential-drive robot using two ultrasonic sensors to measure distance, a PID (Proportional-Integral-Derivative) controller for speed and direction adjustments, and an L293D motor driver to control the motors based on sensor inputs.
\subsubsection{Code}
\begin{lstlisting}[language=C++]
// Arduino Pins
#define L293D_LEFT_EN D2
#define L293D_RIGHT_EN D3
#define L293D_LEFT_IN1 D5
#define L293D_LEFT_IN2 D6
#define L293D_RIGHT_IN1 D7
#define L293D_RIGHT_IN2 D8
#define TRIG_LEFT D0
#define TRIG_RIGHT D1
#define ECHO_LEFT D9
#define ECHO_RIGHT D10
// Constants
#define HALF_SOUND_SPEED 0.1715
#define TARGET_DISTANCE 15
#define DISTANCE_BETWEEN_ULTRASONIC_SENSORS 12
// Parameters to be tested
#define ANGULAR_SPEED_MULTIPLIER 0.8
#define LEFT_POSITIVE_SPEED_MULTIPLIER 1
#define LEFT_NEGATIVE_SPEED_MULTIPLIER 1.2
#define RIGHT_POSITIVE_SPEED_MULTIPLIER 1
#define RIGHT_NEGATIVE_SPEED_MULTIPLIER 1.2
// 1 for debug, 0 for not
#define DEBUG 1
// Adjust the above parameters
// The below code does not need to be changed

#include "PID.hpp"

PID avgPID(461.9, 517.9, 0.00265, 0.472, 1, 65.37, 1.7, 125, 0.15, 140, 0.2436);
PID angPID(461.9, 517.9, 0.00265, 0.472, 1, 65.37, 1.7, 125, 0.15, 140, 0.2436);
double avgV;
double angV;
#if DEBUG
    String* ptr = new String();
#endif

inline double leftIn() {
    digitalWrite(TRIG_LEFT, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_LEFT, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_LEFT, LOW);
    return pulseIn(ECHO_LEFT, HIGH) * HALF_SOUND_SPEED;
}

inline double rightIn() {
    digitalWrite(TRIG_RIGHT, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_RIGHT, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_RIGHT, LOW);
    return pulseIn(ECHO_RIGHT, HIGH) * HALF_SOUND_SPEED;
}

void setup()
{ 
    Serial.begin (9600);
    pinMode(TRIG_LEFT, OUTPUT);
    pinMode(TRIG_RIGHT, OUTPUT);
    pinMode(ECHO_LEFT, INPUT);
    pinMode(ECHO_RIGHT, INPUT);
    pinMode(L293D_LEFT_IN1, OUTPUT);
    pinMode(L293D_LEFT_IN2, OUTPUT);
    pinMode(L293D_RIGHT_IN1, OUTPUT);
    pinMode(L293D_RIGHT_IN2, OUTPUT);
    avgV = 0;
    angV = 0;
}

void loop() {
    double left = leftIn();
    double right = rightIn();
    double avg = left + right;
    double ang = atan2(left - right, DISTANCE_BETWEEN_ULTRASONIC_SENSORS);

    #if DEBUG
        ptr->clear();
        avgV += avgPID.update((avg - TARGET_DISTANCE), millis(), ptr);
        Serial.println("Average Speed PID Update:");
        Serial.println(*ptr);
        ptr->clear();
        angV += angPID.update((ang - TARGET_DISTANCE), millis(), ptr) * ANGULAR_SPEED_MULTIPLIER;
        Serial.println("Angular Speed Update:");
        Serial.println(*ptr);
        ptr->clear();
    #else
        avgV += avgPID.update((avg - TARGET_DISTANCE), millis());
        angV += angPID.update((ang - TARGET_DISTANCE), millis()) * ANGULAR_SPEED_MULTIPLIER;
    #endif

    double leftV = avgV + angV;
    double rightV = avgV - angV;

    leftOut(CLAMP(leftV, 255, -255));
    rightOut(CLAMP(rightV, 255, -255));

    delayMicroseconds(10000);
}

inline void leftOut(double leftV) {
    #if DEBUG
        Serial.println("Left Velocity: " + String(leftV));
    #endif
    leftV *= (leftV < 0)?LEFT_NEGATIVE_SPEED_MULTIPLIER:LEFT_POSITIVE_SPEED_MULTIPLIER;
    #if DEBUG
        Serial.println("Left Output: " + String(leftV));
    #endif
    if (leftV > 0) {
        analogWrite(L293D_LEFT_IN1, 0);
        analogWrite(L293D_LEFT_IN2, leftV);
    } else {
        analogWrite(L293D_LEFT_IN1, -leftV);
        analogWrite(L293D_LEFT_IN2, 0);
    }
}

inline void rightOut(double rightV) {
    #if DEBUG
        Serial.println("Right Velocity: " + String(rightV));
    #endif
    rightV *= (rightV < 0)?RIGHT_NEGATIVE_SPEED_MULTIPLIER:RIGHT_POSITIVE_SPEED_MULTIPLIER;
    #if DEBUG
        Serial.println("Right Output: " + String(rightV));
    #endif
    if (rightV > 0) {
        analogWrite(L293D_RIGHT_IN1, 0);
        analogWrite(L293D_RIGHT_IN2, rightV);
    } else {
        analogWrite(L293D_RIGHT_IN1, -rightV);
        analogWrite(L293D_RIGHT_IN2, 0);
    }
}
\end{lstlisting}
\subsubsection{Pin Definitions}
\begin{itemize}
\item \textbf{L293D motor control pins:}
\begin{itemize}
\item \texttt{L293D\_LEFT\_EN} and \texttt{L293D\_RIGHT\_EN}: Enable pins for the left and right motors.
\item \texttt{L293D\_LEFT\_IN1}, \texttt{L293D\_LEFT\_IN2}, \texttt{L293D\_RIGHT\_IN1}, \texttt{L293D\_RIGHT\_IN2}: Input pins for controlling the direction of the motors.
\end{itemize}
\item \textbf{Ultrasonic sensor pins:}
\begin{itemize}
\item \texttt{TRIG\_LEFT} and \texttt{TRIG\_RIGHT}: Trigger pins for the left and right ultrasonic sensors.
\item \texttt{ECHO\_LEFT} and \texttt{ECHO\_RIGHT}: Echo pins for the left and right ultrasonic sensors that return the duration of the reflected sound wave.
\end{itemize}
\end{itemize}
\subsubsection{Constants}
\begin{itemize}
\item \textbf{HALF\_SOUND\_SPEED}: Constant used to convert the echo time into a distance. The value \texttt{0.1715} is derived from the speed of sound.
\item \textbf{TARGET\_DISTANCE}: The target distance that the robot should maintain between the two sensors (in centimeters).
\item \textbf{DISTANCE\_BETWEEN\_ULTRASONIC\_SENSORS}: The distance between the two ultrasonic sensors mounted on the robot, which is used to calculate angular adjustments.
\end{itemize}
\subsubsection{PID Tuning Parameters}
\begin{itemize}
\item \textbf{PID Controllers (\texttt{avgPID} and \texttt{angPID})}: Two PID controllers are used:
\begin{itemize}
\item \texttt{avgPID}: Controls the average speed to keep the robot at the target distance.
\item \texttt{angPID}: Controls the angular speed to maintain proper alignment based on the sensor readings.
\end{itemize}
The values provided for the PID controllers (like 461.9, 517.9, etc.) are the tuning parameters for each PID term (P, I, D).
\end{itemize}
\subsubsection{Functions and Code Flow}
\begin{itemize}
\item \textbf{\texttt{leftIn()} and \texttt{rightIn()}}: These inline functions trigger the ultrasonic sensors by sending a pulse and measuring the time it takes for the sound to return. The return time is converted into a distance using the formula:
\[
\text{distance} = \frac{\text{time} \times \text{speed of sound}}{2}
\]
The resulting distance is then returned.
\item \textbf{\texttt{setup()}}: This function runs once when the program starts. It initializes serial communication, sets pin modes for the motor control and ultrasonic sensors, and initializes the velocity variables (\texttt{avgV} and \texttt{angV}).
\item \textbf{\texttt{loop()}}: This function runs repeatedly. It does the following:
\begin{enumerate}
\item Reads the distance from the left and right ultrasonic sensors using \texttt{leftIn()} and \texttt{rightIn()}.
\item Calculates the average distance (\texttt{avg}) and the angular difference (\texttt{ang}) between the two sensors.
\item Applies the PID controllers to adjust the average speed and angular speed to maintain the target distance.
\item Sets the left and right velocities (\texttt{leftV} and \texttt{rightV}) based on the PID updates and applies any necessary adjustments to control the motors.
\item Sends the control signals to the motors using \texttt{leftOut()} and \texttt{rightOut()}.
\end{enumerate}
\end{itemize}
\subsubsection{Motor Control (\texttt{leftOut()} and \texttt{rightOut()})}
\begin{itemize}
\item \texttt{leftOut()} and \texttt{rightOut()}: These inline functions are responsible for sending control signals to the motor driver (L293D). The functions adjust the speed based on the calculated velocity and apply any speed multipliers to tune motor behavior. The \texttt{analogWrite()} function is used to set the motor speeds, where:
\begin{itemize}
\item Positive velocities drive the motors forward.
\item Negative velocities drive the motors backward.
\end{itemize}
\end{itemize}
\subsubsection{Debugging}
If \texttt{DEBUG} is set to 1, additional information about the PID updates and motor velocities is printed to the serial monitor for troubleshooting and performance analysis.
\ssc{tools I used: termux debian vi, texlive, my latex-toolkit and termux-sh Android non root

\subsection{Development History}
The development of this PID (Proportional-Integral-Derivative) controller project is rooted in control theory, a field of engineering that focuses on the behavior of dynamic systems. What makes us take the initiative is the auto-following kart lesson in our living technology class. We aim to make an auto-following kart from scratch with Arduino and wooden boards and make it as quality as possible on a constrained budget.
\subsubsection{Control Theory and PID Controllers}
The development of this PID (Proportional-Integral-Derivative) controller project is rooted in control theory, a field of engineering that focuses on the behavior of dynamic systems. PID controllers are a cornerstone of modern control systems. They are designed to automatically adjust system outputs based on feedback to minimize error, allowing for precise control of dynamic systems. The PID controller operates based on three fundamental components:
\begin{itemize}
\item \textbf{Proportional Control (P)}: Responds proportionally to the current error value, providing immediate correction based on how far the system is from the desired state.
\item \textbf{Integral Control (I)}: Addresses accumulated past errors, ensuring that the system reaches the desired state even if there are persistent biases.
\item \textbf{Derivative Control (D)}: Predicts future errors based on the rate of change of the error, providing a damping effect to reduce overshoot and oscillation.
\end{itemize}
The tuning of these parameters is crucial for achieving optimal performance. The traditional Ziegler–Nichols tuning method has served as a foundational approach for many engineers, providing empirical guidelines for setting PID parameters based on system behavior.
\subsubsection{Initial Implementation}
The journey began with a simple implementation of the traditional PID controller. The focus was on creating a basic class structure in C++ that encapsulated the PID logic, allowing for straightforward application in simulations.
\begin{itemize}
\item \textbf{Key Features}:
\begin{itemize}
\item Basic PID calculations.
\item Initial support for both Arduino and non-Arduino environments through conditional compilation.
\end{itemize}
\end{itemize}
\subsubsection{Enhancements and Adaptive Features}
As the initial implementation was tested, several limitations became apparent, particularly regarding responsiveness and stability. This prompted the incorporation of advanced features such as:
\begin{itemize}
\item \textbf{Adaptive Gain Adjustment}: Inspired by the need for dynamic responsiveness, the proportional gain $K_p$ was made adaptable based on the error's rate of change. This enhancement allowed for better handling of transient behaviors in the system.
\item \textbf{Adaptive Integral Term}: To mitigate integral windup, the integral gain $K_i$ was adjusted based on observed error amplitude. This feature improved system stability during sustained error conditions.
\end{itemize}
\subsubsection{Error History Management}
To accurately compute the integral and derivative terms, a robust error history management system was implemented. This system utilized a linked list structure to store past error values and timestamps, enabling precise calculations for both the integral and derivative components. The integration of error history management was crucial for implementing more advanced tuning strategies, inspired by established control theory practices.
\subsubsection{Additional Derivative Term}
Recognizing the need for improved damping characteristics, an additional derivative term $K_{dd}$ was introduced. This term accounted for the acceleration of error changes, allowing the controller to anticipate and react to rapid fluctuations more effectively.
\subsubsection{Testing and Simulation Framework}
With the PID logic in place, attention turned to building a comprehensive simulation framework to test various PID configurations. The introduction of the \texttt{Car} class for simulating follower and leader vehicles added a practical context for evaluating PID performance in a dynamic environment.
\begin{itemize}
\item \textbf{PID Testing Function}: A dedicated function was developed to simulate the interaction between the leader and follower karts, providing insights into how different PID parameters affected system behavior.
\end{itemize}
\subsubsection{Optimization and Multi-threading}
To facilitate further exploration of PID parameter tuning, optimization functions were integrated. Utilizing multi-threading allowed for the concurrent evaluation of multiple parameter combinations, greatly enhancing the testing efficiency. The optimization framework also included mechanisms for result logging and progress tracking, making it easier to analyze and visualize outcomes.
\subsubsection{Arduino Auto-Following Kart}
We use two ultrasonic sensors to measure the distance on both sides. The difference in distance helps adjust the robot's angular velocity, while the average of both distances adjusts its linear speed. The PID controllers fine-tune these adjustments to ensure the robot stays at the target distance, while adjusting its orientation to keep the two sensors aligned. The L293D motor driver uses these velocity values to control the left and right motors, adjusting the robot's movement accordingly.

\section{硬體結構組裝與線路配置}

\section{硬體參數優化}

\end{document}